%-------------------------------------------------------------------------------
\section{Methodology}

% We need these declarations to use algorithms based on Fu et al.
\algblock{Input}{EndInput}
\algnotext{EndInput}
\algblock{Output}{EndOutput}
\algnotext{EndOutput}
\newcommand{\pdiff}{diff_{peak}}

%-------------------------------------------------------------------------------
In order to confirm the findings presented in Fu et.al.\cite{fu_autofz_2023}, we implemented our 
own instances of \texttt{autofz}. We implemented our evaluation environment by:

\begin{enumerate}
    \item Installing the containers provided by Fu et al. \cite{fu_autofz_2023} on our own
    AMD64 development workstation;
    \item Building our own containers, based on Fu et al. \cite{fu_autofz_2023} on our own
    AMD64 development workstation;
    \item Building our own containers, based on our own modifications to \texttt{autofz} on our own 
    ARM64 (Apple MacBook) laptop devices
\end{enumerate}

Moreover, we tested our implementations of \texttt{autofz} against the targets: exiv2, mp3gain, mojs, and 
tcpdump. Our initial findings validate the results presented in Fu et al.; \texttt{autofz} 
is consistently a top performing against the tested targets.

%-------------------------------------------------------------------------------
\subsection{Autofz on AMD64 - Validating Fu et al.\cite{fu_autofz_2023}}
%-------------------------------------------------------------------------------

To validate the results of Fu et al., we deployed a single physical workstation with 
an AMD FX\texttrademark - 6300 Six-Core Processor (3.5 GHz), 16 GB memory, and 1 TB 
SSD, running Ubuntu 20.04.6 LTS (focal). Containers were built on this host using 
the source code available at the sslab-gatech/autofz repository \cite{noauthor_sslab-gatechautofz_2024} 
and were also installed from fuyu0425/autofz images on docker hub\cite{noauthor_fuyu0425autofz_nodate}.


%-------------------------------------------------------------------------------
\subsection{Autofz on ARM64 - ARMy Fuzzing}
%-------------------------------------------------------------------------------

We have also been able to produce a working tool chain on ARM64, with some significant 
variations from Fu et al. \cite{fu_autofz_2023}. Our ARM64 environment supports 7 of 
the original fuzzers in Ubuntu 22.04 LTS. We configured these in virtual machines 
with the UTM app on host laptops running macOS 14.3.1 on Apple Silicon (ARM64) 
architecture \textbf{(RQ1)}. Key differences are described in Table \ref{arm64-characteristics}.

\begin{table}[ht]
    \begin{tabular}{|l|l|l|l|}
        \hline
                        & Original\cite{fu_autofz_2023} & ARM64 & Reason \\
        \hline
        Ubuntu Version  & 16.04             & 22.04 & 1 \\
        \hline
        aflforkserver.so    & x86\_64           & aarch64 & 2 \\
        \hline
        AFL (original)  & Yes               & Yes & \\
        \hline
        AFLFast         & Yes               & Yes & \\
        \hline
        Angora          & Yes               & No & 4 \\
        \hline
        Fairfuzz        & Yes               & Yes & \\
        \hline
        LAF-Intel       & Yes               & Yes & \\
        \hline
        LearnAFL        & Yes               & No & 3 \\
        \hline
        LibFuzzer       & Yes               & Yes & \\
        \hline
        QSYM            & Yes               & No & 4 \\
        \hline
        Radamsa         & Yes               & Yes & \\
        \hline
        RedQueen        & Yes               & Yes & \\
        \hline
    \end{tabular}
    \caption{Key differences between Original AMD64 and ARM64 Environments}
    \label{arm64-characteristics}
\end{table}

The majority of our changes were made in the \texttt{build.sh} scripts and \texttt{Dockerfile}s
for the affected containers.

There are a number of reasons for the differences between Fu et al.,
and our ARM64 environment. They correspond to the reason numbers in Table 
\ref{arm64-characteristics} and are:

\begin{enumerate}
    \item Ubuntu 16.04 LTS does not support the ARM64 architecture (also called 
    aarch64).
    \item Aflforkserver.so comes from the quickcov package, developed to support 
    the Cupid research project\cite{guler_cupid_2020}. We had to recompile it for aarch64.
    \item Learn AFL does not properly compile instrumented binaries for aarch64.
    \item Angora and QSYM are written such that they are dependent upon the x86\_64 ISA.
    They do not support other architectures.
\end{enumerate}

Our modified kit is published open-source and available on GitHub, 
\cite{noauthor_drewinchasautofz_nodate} placed in the arm64 branch 
of the drewinchas/autofz repository.

%-------------------------------------------------------------------------------
\subsection{An Additional Metric: Unique Bugs}
%-------------------------------------------------------------------------------

Fu et al.\cite{fu_autofz_2023} recognized that reliance on a single metric for resource 
allocation could potentially lead to unfair comparison with those fuzzers that do not 
utilize an edge coverage metric. Furthermore, our review of the original source 
code shows that \texttt{autofz} is not likely to produce meaningful improvements over individual 
fuzzers unless those individual fuzzers implement the AFL bitmap coverage metric.

We offer that the count of unique bugs discovered during \texttt{autofz}'s preparation phase 
as a useful, if not more universal metric \textbf{(RQ1)}. Eceiza et al.\cite{eceiza_improving_2023}'s 
survey of 36 fuzzers showed that the vast majority of them reported discovered 
bugs as a metric. To demonstrate and evaluate the use of this metric to inform resource allocation, we 
implemented a variation of the preparation phase as Algorithm \ref{prep-phase-with-ub}, 
where $\mathbb{UB}$ is the unique bugs metric.

%
% LaTex below comes from Fu et al.'s source code of their paper; modified for our purposes
%
\begin{algorithm}[ht!]
  \caption{Preparation Phase, unique bugs (ub)}\label{prep-phase-with-ub}
  \small
  \begin{algorithmic}[1]
    \Output
      \State $Exit_{early} \gets$ Did preparation phase exit early?
      \State $T_{remain}$ $\gets$ Remaining time of preparation phase
    \EndOutput
    \Function{dynamic\_prep\_phase}{$\mathbb{F}$, $\mathbb{UB}$, $T_{prep}$, $1$, $C$}
      \State $T_{remain} \gets T_{prep}$
      \While {$T_{remain} > 0$}
        \State $T_{run} \gets min(T_{remain},30)$
        \If {$C == 1$}
          \For {\textbf{each} $f$ $\in$ $\mathbb{F}$}
            \State \Call{run\_fuzzer}{$f$, $T_{run}$}
          \EndFor
        \Else \Comment{multi-core implementation}
          \State \Call{run\_fuzzers\_parallel}{$\mathbb{F}$, $T_{run}$, $\frac{C}{|\mathbb{F}|}$}
        \EndIf
        \State $T_{remain} \gets T_{remain} - T_{run}$
        \State $diff_{peak} \gets $\Call{find\_most}{$\mathbb{UB}$}$ - $\Call{find\_least}{$\mathbb{UB}$}
        \If{$diff_{peak} \ge 1$}
          \State \Return $(Exit_{early}=True$, $T_{remain})$
        \EndIf
      \EndWhile
      \State \Return $(Exit_{early}=False, T_{remain})$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

With the addition of this metric, we were able to implement two tie-breaker algorithms 
by combining the use of both metrics in the preparation phase. This is particularly 
useful when no unique bugs are discovered by any fuzzer during the preparation phase. 
In this case, we can use Algorithm \ref{prep-phase-with-ub-bitmap} to fall back to 
resource allocation by bitmap, where $\mathbb{B}$ is the bitmap metric and $\mathbb{UB}$ 
remains unique bugs.

\begin{algorithm}[ht!]
  \caption{Preparation Phase: unique bugs (ub), then bitmap}\label{prep-phase-with-ub-bitmap}
  \small
  \begin{algorithmic}[1]
    \Output
      \State $Exit_{early} \gets$ Did preparation phase exit early?
      \State $T_{remain}$ $\gets$ Remaining time of preparation phase
    \EndOutput
    \Function{dynamic\_prep\_phase}{$\mathbb{F}$, $\mathbb{UB}$, $T_{prep}$, $\theta_{cur}$, $C$}
      \State $T_{remain} \gets T_{prep}$
      \While {$T_{remain} > 0$}
        \State $T_{run} \gets min(T_{remain},30)$
        \If {$C == 1$}
          \For {\textbf{each} $f$ $\in$ $\mathbb{F}$}
            \State \Call{run\_fuzzer}{$f$, $T_{run}$}
          \EndFor
        \Else \Comment{multi-core implementation}
          \State \Call{run\_fuzzers\_parallel}{$\mathbb{F}$, $T_{run}$, $\frac{C}{|\mathbb{F}|}$}
        \EndIf
        \State $T_{remain} \gets T_{remain} - T_{run}$
        \State $diff_{peak} \gets $\Call{find\_most}{$\mathbb{UB}$}$ - $\Call{find\_least}{$\mathbb{UB}$}
        \If{$diff_{peak} \ge 1$}
          \State \Return $(Exit_{early}=True$, $T_{remain})$
        \Else \Comment{fall back to bitmap}
          \State $diff_{peak} \gets $\Call{find\_best}{$\mathbb{B}$}$ - $\Call{find\_worst}{$\mathbb{B}$}
          \If{$diff_{peak} > \theta_{cur}$}
              \State \Return $(Exit_{early}=True$, $T_{remain})$
          \EndIf
        \EndIf
      \EndWhile
      \State \Return $(Exit_{early}=False, T_{remain})$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

Conversely, we can fall back to the unique bugs metric as a tie-breaker as well. This is described in
Algorithm .

\begin{algorithm}[ht!]
  \caption{Preparation Phase: bitmap, then unique bugs (ub)}\label{prep-phase-with-bitmap-ub}
  \small
  \begin{algorithmic}[1]
    \Output
      \State $Exit_{early} \gets$ Did preparation phase exit early?
      \State $T_{remain}$ $\gets$ Remaining time of preparation phase
    \EndOutput
    \Function{dynamic\_prep\_phase}{$\mathbb{F}$, $\mathbb{UB}$, $T_{prep}$, $\theta_{cur}$, $C$}
      \State $T_{remain} \gets T_{prep}$
      \While {$T_{remain} > 0$}
        \State $T_{run} \gets min(T_{remain},30)$
        \If {$C == 1$}
          \For {\textbf{each} $f$ $\in$ $\mathbb{F}$}
            \State \Call{run\_fuzzer}{$f$, $T_{run}$}
          \EndFor
        \Else \Comment{multi-core implementation}
          \State \Call{run\_fuzzers\_parallel}{$\mathbb{F}$, $T_{run}$, $\frac{C}{|\mathbb{F}|}$}
        \EndIf
        \State $T_{remain} \gets T_{remain} - T_{run}$
        \State $diff_{peak} \gets $\Call{find\_best}{$\mathbb{B}$}$ - $\Call{find\_worst}{$\mathbb{B}$}
        \If{$diff_{peak} > \theta_{cur}$}
          \State \Return $(Exit_{early}=True$, $T_{remain})$
        \Else \Comment{fall back to bitmap}
          \State $diff_{peak} \gets $\Call{find\_most}{$\mathbb{UB}$}$ - $\Call{find\_least}{$\mathbb{UB}$}
          \If{$diff_{peak} \ge 1$}
              \State \Return $(Exit_{early}=True$, $T_{remain})$
          \EndIf
        \EndIf
      \EndWhile
      \State \Return $(Exit_{early}=False, T_{remain})$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\textbf{Usage.} Implementation of these algorithms required some modifications to \texttt{autofz}'s 
command line interface, as well as modifications to the drawing program. When invoking 
autofz, the user may now specify \texttt{\textendash-discriminator bitmap | ub | ub-bitmap | bitmap-ub},
where:

\begin{itemize}
  \item \texttt{\textendash-discriminator bitmap} invokes \texttt{autofz} with AFL bitmap as the 
  fuzzer discriminator. This is the original \texttt{autofz} behavior. It is also the default behavior 
  when the \texttt{\textendash-discriminator} is not passed.
  \item \texttt{\textendash-discriminator ub} invokes \texttt{autofz} with unique bugs as discriminator. The 
  value for $\theta$ is ignored, as the discrimination threshold is fixed at 1, as described 
  in Algorithm \ref{prep-phase-with-ub}.
  \item \texttt{\textendash-discriminator ub-bitmap} invokes \texttt{autofz} with unique bugs as discriminator, 
  and bitmap as tie-breaker, as described in Algorithm \ref{prep-phase-with-ub-bitmap}.
  \item \texttt{\textendash-discriminator bitmap-ub} invokes autofx with bitmap as discriminator, 
  with unique bugs as tie-breaker, according to Algorithm \ref{prep-phase-with-bitmap-ub}.
\end{itemize}

Similarly, we modified the \texttt{autofz-draw} tool in order to create plots that 
differentiate between the new resource allocation algorithms. It now plots \texttt{autofz+bitmap}, 
\texttt{autofz+ub}, \texttt{autofz+ub-bitmap}, and \texttt{autofz+bitmap-ub}. In our 
implementation, \texttt{autofz+bitmap} is equivalent to the original \texttt{autofz}

\textbf{Get it.} Our modified kit is published open-source and available on GitHub at \texttt{drewinchas/autofz}\cite{york_drewinchasautofz_2024}. 
The main branch, \texttt{ub}, is a fork of the original \texttt{sslab-gatech/autofz}\cite{noauthor_sslab-gatechautofz_2024} 
repo, but it has been modified to only include the changes to \texttt{autofz} and \texttt{autofz-draw} 
that are necessary to support unique bugs as \texttt{discriminator} and the additional algorithms. 

The 'ARMy Fuzzing' kit, in the \texttt{arm64} branch\cite{noauthor_drewinchasautofz_nodate}, contains 
all changes necessary to support unique bugs as \texttt{discriminator}, in addition to those made for 
compatibility with Ubuntu on ARM64. 